
In this video, we're gonna put together
what we've learned about first and follow
sets to construct LL1 parsing tables. Our
goal is to construct a parsing table T for
a context free grammar G. And this is done
by production. So we're gonna do this one
production at, at time. And we're going to
in turn, consider each production, A goes
to alpha in the grammar G. And so the
first case Is if we are trying to figure
out whether we can use A goes to alpha and
T happens to be in the first of alpha.
Alright, so if we know that some terminal
T is in the first of the right hand side,
then. If we were in a situation where A
was the leftmost non terminal, and T was
the next token of input, then, then
expanding by A goes to alpha would be a
good move because the alpha could
potentially, through more, productions,
match the T. And so we'll add to the
parsing table at the A, T entry, The right
hand side alpha. Alright, the other
situation that we're interested in is,
what if we need to get rid of, the A,
okay? So if the A cannot possibly match
the T, alright? So let's say the T is not
in the first of alpha, or we have some
other situation where we want to erase the
A. Well, then it would be okay, to use
production A goes to alpha, provided that.
Alpha can actually go to Epsilon, so alpha
can go away completely, Alright? So we can
eliminate all trace of the A. And T
follows A in the grammar. So T is able to
come after, excuse me, T is able to come
after A in some derivation. So if T is in
the follow of A, and the right hand side
of the [inaudible] code epsilon, then we
add the move that when A is the leftmost
non terminal, and T is the next input, we
can expand A by A goes to alpha. And
finally, a special case for dollar,
because dollar's technically not a
terminal symbol. If we're at the end of
the input, okay, so we have some stuff
left on the stack, particularly we have if
nonterminal a is still our leftmost
nonterminal, but we've run out of input,
well then our only hope is to get rid of
the a completely. And so we want to pick a
production for a that can go to epsilon,
so we look for a production a goes to
alpha, where epsilon is in the first of
alpha, and dollar can follow a in a
derivation. So that is the procedure, or
those are the rules, for constructing a
parsing table. And now let's work through
an example. So here's our favorite grammar
that we've been looking at for the last
few videos. And now let's take a look at
what the parsing table will look like,
alright? And the parsing table will
consist of, columns that are labeled by
the terminal symbols of the grammar. All
right, so here we'll have open paren,
closed paren, plus times and inch. And
then the rose will be labeled by the
terminal symbol, so we'll have E, T, X,
and Y. All right, and now we're just going
to take each production, and apply our
rules, and see what entries in the table
we create. All right, so when would we use
E goes to TX? Alright, well, so the first
thing to observe about this production is
that it cannot produce epsilon on the
right hand side. So TX always produces at
least one terminal. And so, the second
case, where we're interested in whether
the production can go to zero, as it could
go to epsilon, excuse me, is not going to
apply. All right, So we just have to
consider what it can generate in the first
position. So the only things that this
[inaudible] can generate in the first
position are things that are in the first
of T, which are open paren and int. So
there are two situations in which we will
use the production E goes to TX, that is
if E is the leftmost nonterminal, and the
next input is an open paren. Okay? And the
other one is that, if the next input is a
[inaudible], alright? Okay, so now let's
take a look at this production. Right. So
when are we going to use T goes to open
paren E closed paren. Well if T is the
leftmost non-terminal, alright? That's
this one on the left hand side and an open
paren, is the next symbol in the input,
kay. That's the only thing in the first of
this right hand side. Then it would be a
good move to expa nd by open paren E
closed paren. So there's only one
situation. Where we use that production.
Alright? And for the other production, the
other T production, we're going to use
that when T is the leftmost nonterminal,
and there's an INT in the input. So over
here, we'll have [inaudible]. And I forgot
one column over here for dollar. So we'll
stick dollar in there at the very end.
Okay? So now, we've covered these first
three productions. Let's take a look at
this production. So when would we use X
goes to plus E. Well clearly the only
thing on the first of the right hand side
is plus, and the terminal, symbol on the
right hand side is X, so the X plus entry
we would want to expand by X goes to plus
E. And similarly for Y, the production,
the first production involving Y, when Y
is the terminal, non terminal we're trying
to expand and there's a times in the
input, we would use the production Y goes
to times T. Okay? And now we just have the
two epsilon productions left. And these
are the only productions, actually, that
can go to epsilon. And so when would we
use, when would we use X goes to epsilon
or Y goes to epsilon. Alright, so recall
that we need to know. What is in the
follow of X in order to know when to use X
goes to epsilon. And we computed that in
the last lecture. But let's just write it
down again here. Okay. And so what was in
the follow of x, well we had to look at
where x was used in the grammar, x was
used there. I, it appears at the right
hand side of the production. So it would
be things that were in the follow of e.
What was in the follow of e, well, e is
the start symbol, so [inaudible] is in the
follow of e, close paren is in the follow
of e. Alright? And then what was in the
follow of y. That's the other one where
we'll need to know the follow set. Again
we have to look at where Y is used so Y is
used there. That means everything that's
in the follow of T is in the follow of Y.
The follow of y will therefore include the
first of x because x can come after t. So
plus will be in the follow of y. Alright
but then x can go to epsilon and so
everything is in the follow of E will be
in the follow of t and therefore also in
the follow of y. So the other two things
in the follow of y were the dollar sign
and close paren. Alright and so this is
saying okay, is that if we are in a
situation. Where we have, an X. Okay?
Let's just focus on the X goes to epsilon
production for a moment. Let's say that we
have X on the stack, okay, on top of the
stack, and $ is our next input. Well, what
can we do? At the end of the input we have
to get rid of the X so obviously we want
to use the X goes to epsilon move, okay,
so that makes sense. And the other
situation that follows it tell us to use X
goes to epsilon, as if there is a) on the
stack, because the X cannot generate a) by
itself. But hopefully some other symbol
that's on the stack will be able to
generate once we get rid of the x okay so
we also use x goes to epsilon In this
situation. And then [inaudible] for follow
of Y, or for Y goes to epsilon, that
production. There are three things in the
follow, three terminals in the follow of
Y. And we should use Y goes to epsilon if
they are the next thing in the input. So,
so, if we see a plus and we're trying to
expand a Y we'll use Y goes to epsilon. If
we see a closed paren and we see, and
we're trying to expand a Y we'll use Y
goes to epsilon. And finally if we're
completely out of input and we still have
a Y left over, we'll use Y goes to
epsilon. And that is the complete parsing
table, all right? And now you can see. How
this will work in every situation, Okay.
For our leftmost on terminal, and for
every possible input or lack of input, we
have a production that we can use. And now
there are a lot of blank entries in this
table. And what do those correspond to?
Let's say that we, we're trying to expand
x. And the next input symbol was a open
paren. Well, there's no entry here. Okay,
so that's an error. That's a parsing
error. So whenever you encounter a blank
entry in a table, you try to view the
blank entry when you're parsing, that's
when you [inaudible] a parsing error,
because what this tells us, the fact that
there's a blank entry, it tells us that
there is no valid move. There is no way
that we could parse that string. And we
discovered that at the point where we
tried to access an error or blank entry in
the table. So now, let's consider what
happens when we try to build an LL1
parsing table for a grammar that is not
LL1. And let's take a look at the simple
left recursive grammar that we have looked
at before. So S goes to SA is one
production, and S goes to B is the other
production. And to build a parsing table
for this, we'll need to know the first and
follow sets. So let's take a look at the
first of S. Alright. So what can S produce
in the first position? Well, it can
clearly produce a B. And, there's no
epsilon. There's no possibility of
generating epsilon from S. As a matter of
fact that's the only thing that's going to
be in the first of S. And what about the
follow of S, well, what can follow an S?
Well that's the start symbol, so clearly
dollar isn't the follow of S. And then the
sub-terminal, the terminal A appears right
after S in the first production, so A, is
also in the follow of S. And now we're
ready to build our table. And it's going
to be a very small table, because we only
have one non-terminal. And then we have
two terminals, A and B. And we have the
end of input symbol. So it's just three
entries potentially, in this table,
Alright? And so now, let's take each
production, and see where we should put
it. So let's just take a look at the
second production first. Cuz that's
[inaudible] for no particular reason. So
if S goes to B, when should we use that?
Well, clearly, if we see a B in the input,
this would be a good one to use. Cuz
'cause, the because that, the first of the
right hand side includes B, alright? So,
so S goes to B. Would be used if we see a
B in the input. And now what about S goes
to SA? Well here, again this can't
generate epsilons so we're only interested
in what it can produc e in the first
position. And once again, the first of S
is just B. And so we also have the move,
in the SB entry, we would have the move as
goes to SA. And now we see the problem,
right? Here we have an entry that has
multiple moves. This is a multiply defined
entry. Okay, and what does that mean? Well
that means if we see an s in if we have an
s and we want to expand, okay we're trying
to, if s is our leftmost non terminal so
it's at the top of the stack, and b is our
next input symbol, alright, this table
doesn't tell us exactly what move to make.
It's not deterministic. It says there's
two possible moves. That we can make. And
so, this is how you know a grammar is not
[laugh](1) because if it winds up that you
build the [laugh](1) parsing table and you
have more than one entry. More than one
possible move in some, position in the
table, some entry, excuse me. I used the
word entry incorrectly. So if you wind up,
let me say that again. If you wind, if you
build the table and some entry in the
table has more than one move in it, then,
there's not an unique move For every
situation for the parser. And that grammar
is not [laugh](1) So, we just said if any
entry is multiply defined in the parsing
table, then the grammar is not LO1. And in
fact, this is the definition of an LO1
grammar, so the only way to be sure that
the grammar is LO1 or the mechanical way
to check that the grammar is LO1, is to
build the LO1 parsing table and see if all
the entries in the table is unique. Now,
that, we do know, however, that there are
certain classes of grammars that are
guaranteed not to be L1, not to be L1. And
what are some of those? Well, any grammar
that is not left factored. Will not be
lo1, okay. Any grammar that is left
recursive will not be lo1. Okay any
grammar that is ambiguous, Is also
guaranteed to not be L1. But this is not
an exhaustive list. Other grammars are not
L1 too. So in particular If the grammar
required more than one token of look
ahead, it would not be all one. But even
that isn't a complete list. So e ven
grammar is beyond that, that are not going
to be all one. So what this amounts to,
these three things here, amount to quick
checks that you can do. To test whether a
grammar is guaranteed not to be L1. But,
if, just because a grammar is left
factored, and it is not left recursive,
and is ambig-, unambiguous, that doesn't
guarantee that it's L1. And the only way
to know for sure is to construct the
parsing table, and see if all of the
entries in it are unique. And
unfortunately it turns out. That most
programming languages, they're context
free grammar. So the grammars that
describe most programming languages are
not LL1. And, the L1 grammars are too weak
to actually capture all of the interesting
and important constructs in commonly using
programming languages. And there are more
powerful. Formalism for describing
grammars and or practical grammars, and
we're going to be looking at those in
future videos. It turns out that they
build on everything that we've learned
here over the last few videos for Elmer
grammar so none of that will be wasted,
but they assembled those ideas in a more
sophisticated way to build more powerful
parts.
