
In this video we're finally gonna come to
the technical highlight of bottom up
parsings After all the definitions of the
previous videos now we're actually gonna
be able to give the algorithm for
recognizing viable prefixes. So let's dive
straight into the algorithm. The first
step is really just a very technical point
and it's not, not that important. But
we're going to do it anyway because it
makes things simpler Is to add a dummy
production as prime goes to S to our
grammar of interest G. So, just to set the
stage we are trying to compute the viable
prefixes of G. We're trying to come up
with a, algorithm for recognizing the
viable prefixes of G. If S is the start
symbol, we're going to make up a new start
symbol as prime, so as prime would be the
new start symbol of augmented grammar and
it's just one production for as prime as
prime goes to S. Right. So this just allow
us to know exactly where our start symbol
is used, in particular our new start
symbol as prime is only used in one place
and. Left hand side of this one
production, and that just makes things a
little bit simpler. Now, recall what we
are trying to do. We claim that the set of
viable prefixes for a given grammar is
regular and so what we're going to do is
we're going to construct a
non-deterministic final automaton that
recognizes the viable prefixes, okay? And
the states of this NFA are going to be the
items of the grammar. Now the input to the
NFA is the stack. So the NFA reads the
stack, okay? And then it, So let's
indicate this, so the NFA is gonna take
the stack as an argument, and it's either
gonna say yes, that's a viable prefix, or
no. And it's gonna read the stack from
bottom to top. So it's gonna start at the
bottom of the stack, and read towards the
top of the stack. And our goal here is to
write a non entromystic finite automaton
that recognizes the valid stacks of the
purser. So that is how we'll know. That,
our parser hasn't really counted any parse
errors. Because this automaton that we're
going to construct will always output e
ither yes, this stack is okay, meaning it
could wind up, parsing, the input. Or no,
what we've got on the stack now, doesn't
resemble any valid stack for any possible
parse of any input string for this
grammar. Okay, so let's think about, what
we, what we need the moves of this machine
to be. So let's say that we're in the
state E, arrow, alpha dot X beta. Now,
what does that say? So that says that so
far, we've seen alpha on the stack. Okay,
so remember the machine is reading the
stack from bottom to top. This records the
fact that the machine has already seen
"alpha" on the stack. So, what would be an
okay thing to see next on the stack? Well,
if this is a valid stack, if having
"alpha" on the stack at this point is
valid, well then certainly it would be
okay if the next thing on the stack was an
"X." So, we have a transition that if
we're in this state Where we are working
on this production, and we've seen alpha
on the stack. If the next thing is an X on
input X, then we can go to this state.
Where now we record the fact that we've
seen alpha X on the stack, and we're
waiting to see, the remaining portion,
beta, of that production. Okay, so this is
one kind of move that the non triamistic
phymotine can make, and again, we do, we
add this kind of a move for every item. So
for every item in the grammar, I, if it,
if the dot is not all the way at the right
end, then there will be a move like this
where the dot moves over, for whatever
symbol happens to come to the right of the
dot. The other class of transitions are
the following And these are the, the more
interesting ones. So let's say that we're
in this, configuration here. Where again,
we've seen alpha. And then the next thing
on the stack is X. And here, X is a non
terminal. [sound]. And I should have said
that in the previous case. X was either a
terminal or a non terminal. So this X here
is any grammar symbol, not just a non
terminal. But this, #four here, the, the
moves here in part four are specifically
for non terminals. Okay, so anyway, if, X
is not on the stack. Okay, let's assume
that we've seen alpha, and then the next
thing on the stack is not S. Well, is it
possible that there could be a valid
configuration of the parser where we saw
alpha but then X didn't appear next? And,
the answer is yes because as we said
before, the stack is a sequence of partial
right hand sides. So it could be that all
that's on the stack right now for this
production. Is alpha and if the next thing
on the stack is eventually going to reduce
to X. It might not be X itself, it might
be something that will eventually reduce
to X. Well, what does that mean? Well,
that means that whatever is there on the
stack has to be derived from X, it has to
be something that can be Generated by
using a sequence of X productions, 'cause
eventually it's going to reduce the X. So
for every item that looks like this, and
for every production for X now we're going
to add the following move, we're going to
say that if there's no X on the stack,
well then, we can make an epsilon move, we
can just shift to a state where we try to
recognize the right hand side plus
something derived from X. And these are
the only two kinds of moves Either the
items, eith sorry, either the grammar
symbols we're looking for are there on the
stack and we extend. >> The prefix of a
right hand side. So this rule here extends
a prefix. So as we see more of that
production on the stack or, it tries to
guess or tries to discover where the ends
of the prefixes are. So if, if alpha's as
much of the production that is on the
stack currently, well then this must be,
this x here must this, this point here
must mark the start of another right hand
side in our stack of right hand sides. So
we would expect to see something derived
from some production for x. Two more
rules. Every state in this automaton is
going to be an accepting state. That means
that if the automaton manages to
successfully consume the entire stack,
then the then the stack is viable. And
just notice that not every state is going
to have transition on every possibl e,
symbol. So there will be plenty of
possible stacks that, that are rejected
simply because the automaton gets stuck.
And finally, the start state of this
automaton is the item as prime goes to dot
S. So remember, the states of the machine
are the items of the grammar. And this is
why we added, this, dummy production, is
just so that we could conveniently name
the start state. So now, let's consider,
one of our, grammars we've been using a
lot, so this is the grammar. And now we're
going to augment it, with the extra
production as prime goes to E. And let's
take a look at the automaton for that
recognizes the viable prefixes of this
grammar. And here it is, and as you can
see, it's rather large it has a lot of
states and a lot of transitions, and I
just want to show it to you here before we
describe how we calculated it, just so you
can get an idea that these [inaudible] for
recognizing viable prefixes for grammars
are actually quite elaborate. But, now
let's break this down and see how it was
produced. So, let's begin with the start
state of this machine, so we have S prime
goes to dot E. And, remember what this
says is we want to be able to reduced to
the start symbol to the new start symbol.
And so we're reading the stack, and we're
hoping to see an E on the stack, and if we
don't then we're happy to see something
derived from E. So, what transition we
make from the state. One possibility is
that we do in fact see an eon a stack, and
in that case the dot simply moves over
saying yes we've read the first item on
the stack or the, we've read the E on the
stack and so we've seen the full right
hand side of this production. Now that
would indicate that we were probably done
with parsing. This is the state that you
would reach, have you'd read the entire
input and successfully parsed it, you
would have reduced the old start symbol
and be about to reduce to the augmented
the, the new start symbol. But if you're
not so fortunate as to see an E on the
stack, then you need to hope that you'll
see something derive fro m E. And there
are a couple of possibilities there. One
is that we could see something that would
eventually use this production, E goes to
T. And since we haven't seen any of it
yet, we put the dot all the way at the
left, indicating that we're hoping to see
a T, which could then reduce to E, and
which could then reduce to S prime. Now if
we don't see a T on the stack by itself
the other possibility is that we could be
working on this production. E goes to, T
plus E. And again, we haven't seen any of
it, so the dot Goes on the left hand side.
And then notice how we're crucially using
the power of nondeterministic automata. So
here we don't know which production is
going to, which right hand side of a
production is going to appear on the
stack. And in fact, I notice that these
productions are not even left factored, so
we don't know whether it's going to be
just a T there or a T plus E, but. We just
use the guessing power of the [inaudible]
chromatin you chose which one to, to use.
Remember the [inaudible] sepse is any
possible choice except. So you can always
guess correctly. So intuitively you can.
You will be able to pick the right one.
Now of course we could compile this down
to a deterministic machine that won't have
to make any guesses. But at this level
we're writing [inaudible] it's extremely
useful not to have to figure out which of
these two productions to use. We can just
try both and see what happens. Now let's
focus on this, state, E goes to dot T.
What are the possibilities there? Well,
one possibility is that we see a T on the
stack. And then we see in a complete right
hand side. And notice how when the dot was
all the way to the right hand side, that
is going to indicate that we're ready to
do a reduce. So we'll talk about that a
little bit later, but essentially that's
how we're going to recognize handles. When
we finally reach a state where the dot is
all the way to the right hand side that's
going to say this could be a handle that
you might want to reduce. Now if we don't
see a T on the stack , then we just see
something derived from T, and there's a
couple of possibilities, a few
possibilities there. One possibility is
that it's going to be the production T
goes to int, so since we're just starting
on this production again, we just put the
dot all the way at the left. Another
possibility we're working on T goes to
(E). And the third possibility that we're
working on T goes to int x T. And each of
the case here, notice that the dots are
all the way at the left indicating that
we're just getting started, we have not
actually seen any of the right hand side
yet. Now let's shift our focus to this
production, E goes to, dot T plus E. This
item, excuse me One possibility is that we
see an E on the see a T on the stack,
okay, in which case the dot just moves
over. And the other possibility is that we
see something derived from T, in which
case we will go to one of the states that
begins a T production. And notice here
that we already have all three of those
items in our automaton. We're just going
to it states that we went to from the item
E goes to dot T. So this, this item, E
goes to dot T plus E, could also move to
those three states. Now let's focus on
this, item here. T goes to dot,
open-paren, E closed-paren. Well, there's
only one possible move here, so this is
only a, a terminal, it's not, it's not a
non-terminal, so there's not going to be
any possibility of having something
derived from open-paren. We just have to
see the open-paren in the input. So
there's only one possible transition here,
which is that we see, the open-paren,
excuse me, on the stack, and the dot just
moves over. Now, from this state, once
again, we got is just next to a, or just
to the left of a non-terminal, so we might
see that non-terminal on the stack or we
might see something derived from that
non-terminal. Well, if we see that
non-terminal on the stack, your dot just
moves over and we get T(E.) indicating
that we've seen an both an ( and E on the
stack and we're still waiting to see the
). Well we might also see somethin g
derived from e, okay. So we add these two
transitions to the two items that begin
productions for e. [sound]. Alright, now,
let's focus on this state. T goes to open
paren E dot closed paren. Again, 'cause
it's a terminal, that the dot it's next to
is only one possible move. We have to see
that open paren if we see anything at all.
And we'll wind up with the item T goes to
open paren E, closed paren dot. And now
we've recognized the entire right hand
side of that production on the stack.
Let's take a look at this, item. So we're
here, because a terminal symbol, the, only
possibility is to read that terminal
symbol on the stack. So this would be the
next item. E goes to T plus dot E.
[sound]. Focusing on that item again
[inaudible] we could possible see an E on
the stack. Right, in which case we would
have recognized the entire writing inside
of this production, We have E goes T+E. Or
we can see something derived from here,
which case we make a transition back to
one of those two states. Now, where we got
productions left to go, or items left to
go Here, we haw T goes to.int. So, we
would have to see it next on to stack, and
that would be the full right hand side of
that production. Down here, we still have
T goes to dot [inaudible] times T. So
again, there's a terminal symbol here
[inaudible]. And so that would be the next
thing we would need to see on the stack
for this production to remain viable. And
once we've seen the [inaudible] we would
like to see the times. So we wind up in
this state and now we've got dot next to
T. So, again, one possibility is that we
see the T on the stack and then we've seen
the full right-hand side of this
production. But we might only see
something derive from T. The might, the,
the T might not be there yet. It might be
in a state where we're still waiting for
the T to appear through some sequence of
reductions. But then we would need to see
something derive from T. And in this case
we would make a transition to one of the
three states that begin the productions
for T. And that 's the full automaton.
That is, those are all the states and all
the transitions for the automaton that
recognizes the viable prefixes of this
